/**
 * Learning System Tools (6-10) Handlers
 * Implementation for v1.4.0 learning tools
 */
export declare const learningMetricsHandler = "\n      case 'learning_metrics': {\n        const sessionId = args?.session_id as string | undefined;\n        const timeWindowDays = (args?.time_window_days as number) || 7;\n        const includeTrends = (args?.include_trends as boolean) ?? true;\n        const groupBy = (args?.group_by as string) || 'task';\n\n        const cutoffTime = Date.now() / 1000 - (timeWindowDays * 24 * 60 * 60);\n\n        // Calculate overall metrics\n        const overallMetrics = db.prepare(`\n          SELECT\n            COUNT(*) as total_episodes,\n            AVG(reward) as avg_reward,\n            AVG(CASE WHEN success = 1 THEN 1.0 ELSE 0.0 END) as success_rate,\n            AVG(latency_ms) as avg_latency,\n            MIN(ts) as first_episode,\n            MAX(ts) as last_episode\n          FROM episodes\n          WHERE ts >= ?\n            ${sessionId ? 'AND session_id = ?' : ''}\n        `).get(sessionId ? [cutoffTime, sessionId] : [cutoffTime]) as any;\n\n        // Calculate grouped metrics\n        const groupField = groupBy === 'task' ? 'task' : groupBy === 'session' ? 'session_id' : 'task';\n        const groupedMetrics = db.prepare(`\n          SELECT\n            ${groupField} as group_name,\n            COUNT(*) as count,\n            AVG(reward) as avg_reward,\n            AVG(CASE WHEN success = 1 THEN 1.0 ELSE 0.0 END) as success_rate,\n            AVG(latency_ms) as avg_latency\n          FROM episodes\n          WHERE ts >= ?\n            ${sessionId ? 'AND session_id = ?' : ''}\n          GROUP BY ${groupField}\n          ORDER BY count DESC\n          LIMIT 10\n        `).all(sessionId ? [cutoffTime, sessionId] : [cutoffTime]) as any[];\n\n        // Calculate trends if requested\n        let trendData = '';\n        if (includeTrends && overallMetrics.total_episodes > 0) {\n          const trendQuery = db.prepare(`\n            SELECT\n              strftime('%Y-%m-%d', ts, 'unixepoch') as date,\n              COUNT(*) as episodes,\n              AVG(reward) as avg_reward,\n              AVG(CASE WHEN success = 1 THEN 1.0 ELSE 0.0 END) as success_rate\n            FROM episodes\n            WHERE ts >= ?\n              ${sessionId ? 'AND session_id = ?' : ''}\n            GROUP BY date\n            ORDER BY date DESC\n            LIMIT 7\n          `).all(sessionId ? [cutoffTime, sessionId] : [cutoffTime]) as any[];\n\n          if (trendQuery.length > 0) {\n            trendData = '\\n\\n\uD83D\uDCC8 Trend Analysis (Last 7 Days):\\n' +\n              trendQuery.map(t =>\n                `  ${t.date}: ${t.episodes} episodes, success: ${(t.success_rate * 100).toFixed(1)}%, reward: ${t.avg_reward.toFixed(3)}`\n              ).join('\\n');\n          }\n        }\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `\uD83D\uDCCA Learning Performance Metrics (${timeWindowDays} days)${sessionId ? ` - Session: ${sessionId}` : ''}\\n\\n` +\n                `Overall Performance:\\n` +\n                `  Total Episodes: ${overallMetrics.total_episodes}\\n` +\n                `  Success Rate: ${(overallMetrics.success_rate * 100).toFixed(1)}%\\n` +\n                `  Average Reward: ${overallMetrics.avg_reward.toFixed(3)}\\n` +\n                `  Average Latency: ${Math.round(overallMetrics.avg_latency)}ms\\n` +\n                `  Time Range: ${new Date(overallMetrics.first_episode * 1000).toISOString().split('T')[0]} to ${new Date(overallMetrics.last_episode * 1000).toISOString().split('T')[0]}\\n\\n` +\n                `Top ${groupBy.charAt(0).toUpperCase() + groupBy.slice(1)}s:\\n` +\n                groupedMetrics.map((g, i) =>\n                  `${i + 1}. ${g.group_name}\\n` +\n                  `   Episodes: ${g.count}, Success: ${(g.success_rate * 100).toFixed(1)}%, Reward: ${g.avg_reward.toFixed(3)}`\n                ).join('\\n') +\n                trendData,\n            },\n          ],\n        };\n      }\n";
export declare const implementationSummary: {
    tools: {
        name: string;
        status: string;
        handler: string;
    }[];
    version: string;
    implementedBy: string;
    timestamp: string;
};
//# sourceMappingURL=learning-tools-handlers.d.ts.map