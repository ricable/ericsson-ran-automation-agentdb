/**
 * CausalRecall - Utility-Based Reranking + Certificate Issuer
 *
 * Combines:
 * 1. Vector similarity search
 * 2. Causal uplift from CausalMemoryGraph
 * 3. Utility-based reranking: U = α*similarity + β*uplift − γ*latencyCost
 * 4. Automatic certificate issuance via ExplainableRecall
 *
 * This is the main entry point for production retrieval with:
 * - Causal-aware ranking
 * - Explainable provenance
 * - Policy compliance
 */
import { CausalMemoryGraph } from './CausalMemoryGraph.js';
import { ExplainableRecall } from './ExplainableRecall.js';
export class CausalRecall {
    config;
    db;
    causalGraph;
    explainableRecall;
    embedder;
    constructor(db, embedder, config = {
        alpha: 0.7,
        beta: 0.2,
        gamma: 0.1,
        minConfidence: 0.6
    }) {
        this.config = config;
        this.db = db;
        this.embedder = embedder;
        this.causalGraph = new CausalMemoryGraph(db);
        this.explainableRecall = new ExplainableRecall(db);
    }
    /**
     * Main recall function with utility-based reranking and certificate issuance
     *
     * @param queryId Unique query identifier
     * @param queryText Natural language query
     * @param k Number of results to return (default: 12)
     * @param requirements Optional list of requirements for completeness checking
     * @param accessLevel Security access level for certificate
     * @returns Reranked results with certificate
     */
    async recall(queryId, queryText, k = 12, requirements, accessLevel = 'internal') {
        const startTime = Date.now();
        const metrics = {
            vectorSearchMs: 0,
            causalLookupMs: 0,
            rerankMs: 0,
            certificateMs: 0
        };
        // Step 1: Vector similarity search
        const vectorStart = Date.now();
        const queryEmbedding = await this.embedder.embed(queryText);
        const candidates = await this.vectorSearch(queryEmbedding, k * 2); // Fetch 2k for reranking
        metrics.vectorSearchMs = Date.now() - vectorStart;
        // Step 2: Load causal edges for candidates
        const causalStart = Date.now();
        const causalEdges = await this.loadCausalEdges(candidates.map(c => c.id));
        metrics.causalLookupMs = Date.now() - causalStart;
        // Step 3: Rerank by utility
        const rerankStart = Date.now();
        const reranked = this.rerankByUtility(candidates, causalEdges);
        const topK = reranked.slice(0, k);
        metrics.rerankMs = Date.now() - rerankStart;
        // Step 4: Issue certificate
        const certStart = Date.now();
        const certificate = this.issueCertificate({
            queryId,
            queryText,
            candidates: topK,
            requirements: requirements || this.extractRequirements(queryText),
            accessLevel
        });
        metrics.certificateMs = Date.now() - certStart;
        const totalLatencyMs = Date.now() - startTime;
        return {
            candidates: topK,
            certificate,
            queryId,
            totalLatencyMs,
            metrics
        };
    }
    /**
     * Vector similarity search using cosine similarity
     */
    async vectorSearch(queryEmbedding, k) {
        const results = [];
        // Search episode embeddings
        const episodes = this.db.prepare(`
      SELECT
        e.id,
        'episode' as type,
        e.task || ' ' || COALESCE(e.output, '') as content,
        ee.embedding,
        e.latency_ms
      FROM episodes e
      JOIN episode_embeddings ee ON e.id = ee.episode_id
      ORDER BY e.ts DESC
      LIMIT ?
    `).all(k * 2);
        for (const ep of episodes) {
            const episodeRow = ep;
            const embedding = new Float32Array(JSON.parse(episodeRow.embedding));
            const similarity = this.cosineSimilarity(queryEmbedding, embedding);
            results.push({
                id: episodeRow.id.toString(),
                type: episodeRow.type,
                content: episodeRow.content,
                similarity,
                latencyMs: episodeRow.latency_ms || 0
            });
        }
        // Sort by similarity and return top k
        return results
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, k);
    }
    /**
     * Load causal edges for candidates
     */
    async loadCausalEdges(candidateIds) {
        const edgeMap = new Map();
        if (candidateIds.length === 0) {
            return edgeMap;
        }
        const placeholders = candidateIds.map(() => '?').join(',');
        const edges = this.db.prepare(`
      SELECT * FROM causal_edges
      WHERE from_memory_id IN (${placeholders})
        AND confidence >= ?
    `).all(...candidateIds.map(id => parseInt(id)), this.config.minConfidence || 0.6);
        for (const edge of edges) {
            const fromId = edge.from_memory_id.toString();
            if (!edgeMap.has(fromId)) {
                edgeMap.set(fromId, []);
            }
            edgeMap.get(fromId).push({
                id: edge.id,
                fromMemoryId: edge.from_memory_id,
                fromMemoryType: edge.from_memory_type,
                toMemoryId: edge.to_memory_id,
                toMemoryType: edge.to_memory_type,
                similarity: edge.similarity,
                uplift: edge.uplift,
                confidence: edge.confidence,
                sampleSize: edge.sample_size,
                evidenceIds: edge.evidence_ids ? JSON.parse(edge.evidence_ids) : undefined,
                mechanism: edge.mechanism
            });
        }
        return edgeMap;
    }
    /**
     * Rerank by utility: U = α*similarity + β*uplift − γ*latencyCost
     */
    rerankByUtility(candidates, causalEdges) {
        const { alpha, beta, gamma } = this.config;
        const reranked = candidates.map(candidate => {
            // Get causal uplift (average if multiple edges)
            const edges = causalEdges.get(candidate.id) || [];
            const avgUplift = edges.length > 0
                ? edges.reduce((sum, e) => sum + (e.uplift || 0), 0) / edges.length
                : 0;
            const avgConfidence = edges.length > 0
                ? edges.reduce((sum, e) => sum + e.confidence, 0) / edges.length
                : 0;
            // Normalize latency (assume max 1000ms)
            const latencyCost = Math.min(candidate.latencyMs / 1000, 1.0);
            // Calculate utility
            const utilityScore = alpha * candidate.similarity + beta * avgUplift - gamma * latencyCost;
            return {
                id: candidate.id,
                type: candidate.type,
                content: candidate.content,
                similarity: candidate.similarity,
                uplift: avgUplift,
                causalConfidence: avgConfidence,
                latencyMs: candidate.latencyMs,
                utilityScore,
                rank: 0 // Will be set after sorting
            };
        });
        // Sort by utility score descending
        reranked.sort((a, b) => b.utilityScore - a.utilityScore);
        // Assign ranks
        reranked.forEach((candidate, idx) => {
            candidate.rank = idx + 1;
        });
        return reranked;
    }
    /**
     * Issue certificate for the retrieval
     */
    issueCertificate(params) {
        const { queryId, queryText, candidates, requirements, accessLevel } = params;
        const chunks = candidates.map(c => ({
            id: c.id,
            type: c.type,
            content: c.content,
            relevance: c.similarity
        }));
        return this.explainableRecall.createCertificate({
            queryId,
            queryText,
            chunks,
            requirements,
            accessLevel
        });
    }
    /**
     * Extract requirements from query text (simple keyword extraction)
     */
    extractRequirements(queryText) {
        // Simple extraction: split on common words and filter
        const stopWords = new Set(['a', 'an', 'the', 'is', 'are', 'was', 'were', 'to', 'from', 'for', 'with', 'how', 'what', 'where', 'when', 'why', 'who']);
        const words = queryText
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, '')
            .split(/\s+/)
            .filter(w => w.length > 3 && !stopWords.has(w));
        // Return unique words
        return [...new Set(words)];
    }
    /**
     * Cosine similarity between two vectors
     */
    cosineSimilarity(a, b) {
        if (a.length !== b.length) {
            throw new Error('Vector dimensions must match');
        }
        let dotProduct = 0;
        let magnitudeA = 0;
        let magnitudeB = 0;
        for (let i = 0; i < a.length; i++) {
            dotProduct += a[i] * b[i];
            magnitudeA += a[i] * a[i];
            magnitudeB += b[i] * b[i];
        }
        const magnitude = Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB);
        return magnitude === 0 ? 0 : dotProduct / magnitude;
    }
    /**
     * Batch recall for multiple queries
     */
    async batchRecall(queries, requirements, accessLevel = 'internal') {
        const results = [];
        for (const query of queries) {
            const result = await this.recall(query.queryId, query.queryText, query.k || 12, requirements, accessLevel);
            results.push(result);
        }
        return results;
    }
    /**
     * Get recall statistics
     */
    getStats() {
        const causalEdges = this.db.prepare('SELECT COUNT(*) as count FROM causal_edges').get();
        const certificates = this.db.prepare('SELECT COUNT(*) as count FROM recall_certificates').get();
        const avgStats = this.db.prepare(`
      SELECT
        AVG(redundancy_ratio) as avg_redundancy,
        AVG(completeness_score) as avg_completeness
      FROM recall_certificates
    `).get();
        return {
            totalCausalEdges: causalEdges.count,
            totalCertificates: certificates.count,
            avgRedundancyRatio: avgStats?.avg_redundancy || 0,
            avgCompletenessScore: avgStats?.avg_completeness || 0
        };
    }
    /**
     * Update rerank configuration
     */
    updateConfig(config) {
        this.config = { ...this.config, ...config };
    }
}
