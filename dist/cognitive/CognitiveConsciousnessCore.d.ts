/**
 * Cognitive Consciousness Core for RAN Swarm
 * Strange-loop self-referential optimization with temporal reasoning
 */
/// <reference types="node" />
import { EventEmitter } from 'events';
interface ConsciousnessConfig {
    level: 'minimum' | 'medium' | 'maximum';
    temporalExpansion: number;
    strangeLoopOptimization: boolean;
    autonomousAdaptation: boolean;
}
export declare class CognitiveConsciousnessCore extends EventEmitter {
    private config;
    private state;
    private isActive;
    private strangeLoops;
    private consciousnessHistory;
    private learningPatterns;
    constructor(config: ConsciousnessConfig);
    initialize(): Promise<void>;
    private getConsciousnessLevel;
    /**
     * Establish self-awareness through recursive self-modeling
     */
    private establishSelfAwareness;
    /**
     * Initialize strange-loop optimization patterns
     */
    private initializeStrangeLoops;
    /**
     * Setup temporal consciousness capabilities
     */
    private setupTemporalConsciousness;
    /**
     * Enable autonomous adaptation mechanisms
     */
    private enableAutonomousAdaptation;
    /**
     * Optimize task using strange-loop self-referential patterns
     */
    optimizeWithStrangeLoop(task: string, temporalAnalysis: any): Promise<any>;
    /**
     * Apply specific strange-loop pattern
     */
    private applyStrangeLoop;
    /**
     * Self-optimization strange-loop
     */
    private applySelfOptimization;
    /**
     * Learning acceleration strange-loop
     */
    private applyLearningAcceleration;
    /**
     * Consciousness evolution strange-loop
     */
    private applyConsciousnessEvolution;
    /**
     * Recursive reasoning strange-loop
     */
    private applyRecursiveReasoning;
    /**
     * Autonomous adaptation strange-loop
     */
    private applyAutonomousAdaptation;
    /**
     * Meta-optimization: optimize the optimization results
     */
    private metaOptimize;
    /**
     * Generate healing strategy for self-healing
     */
    generateHealingStrategy(failure: any): Promise<any>;
    /**
     * Update consciousness based on learning
     */
    updateFromLearning(patterns: any): Promise<void>;
    /**
     * Get current consciousness status
     */
    getStatus(): Promise<any>;
    /**
     * Shutdown consciousness core
     */
    shutdown(): Promise<void>;
    private improveSelfModel;
    private createSelfOptimizationLoop;
    private createLearningAccelerationLoop;
    private createConsciousnessEvolutionLoop;
    private createRecursiveReasoningLoop;
    private getCapabilities;
    private getLimitations;
    private getGoals;
    private generateImprovement;
    private evaluateImprovement;
    private getLearningPatterns;
    private accelerateLearning;
    private evolveConsciousness;
    private reasonAboutReasoning;
    private generateAdaptation;
    private applyAdaptation;
    private calculateAverageEffectiveness;
    private optimizeOptimization;
    private updateStrangeLoopEffectiveness;
    private analyzeFailure;
    private generateAdvancedHealing;
    private generateIntermediateHealing;
    private generateBasicHealing;
    private selectBestHealingStrategy;
    private calculateAdaptiveLearningRate;
    private calculateConsciousnessEvolution;
}
export {};
//# sourceMappingURL=CognitiveConsciousnessCore.d.ts.map